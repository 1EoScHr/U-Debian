#The Missing Semester note
***
##Lec1.Shell & Bash
###基础知识点：  

1. 命令行以空格为分割，所以当命令参数中间有空格时(比如一个文件名)，  
    + 使用引号：`echo "hello world"`  
    + 使用反斜杠转义：`echo hello\ world`  

    这也解释了平时使用时的发现：  
    + ls出来的，是带引号形式  
    + tab补全出来的，是反斜杠转义形式  

2. 命令都存放在`echo $PATH`出来的用:分割的目录里  
    每当打出命令时，都会在这些目录中遍历，直到找到这个命令  
    所以`which xxxx`就是在这些里找到存放位置，只能用来找命令  
    也可以直接根据绝对路径和相对路径到存放每命令的地方执行，如`/usr/bin/echo helloworld`  
    写通用脚本时，对于常见命令，一般不要带路径，直接引用，以免因为存放目录不同而找不到  

3. ~:总指向用户目录 `cd`与`cd ~`会带到/home/xxx里面  
    -:总指向上次所在的目录 `cd -`

4. 命令除过路径，还可以加别的参数，使用方法可以用`--help`引出查看  
    一般的，参数都用`-`或`--`引出  
    参数分为*flag*与*option*，  
    + falg是标志位，后面不加别的，用来启用或禁用某功能，譬如ls命令的`-l`指开启详细输出  
    + option是可选参数，后面要跟有一个值(有时候会有一个默认值)，用于修改命令的默认行为与输出，如ls命令的`-C`，有默认参数，来实现以多列形式输出；`--color`是要启动颜色显示来区分不同文件  

5. `ls -l` 代表详细输出，可以得到的有用信息：  
    + **第一个**：为"d"则是一个目录，为"-"则是一个文件，为"l"则是一个字符连接，此外还有"c""b""s"，用到再看  
    + **下九个**：分3x3三组，代表不同用户的文件权限，依次为*文件所有者*、*拥有文件的用户组*、*非所有者的其他用户*，前两者可以在第二列中看到  
其中，"r""w""x"对于**文件**为*读取*、*写入*、*执行*，对于**目录**为*查看其中内容*、*重命名or新建or删除其中文件*、*搜索or访问目录权*，"-"表示无对应权限  
    + **有趣的点**：如果没有目录的"w"但是有其中一个文件的"w"，最后只能把文件变成空白而不能删除，因为没有目录的"w"权；一个文件只有其所有父目录和自身都拥有"x"权才能被访问  

6. *`ls -R`*递归的列出文件目录结构，但不如**`tree`**，还有新的nb工具**`broot`**，可视化，模糊匹配  

6. mv 除了**移动路径**，还可顺带**改名**  
    + 用法：mv 现有路径 新路径 (新文件名)  

    同理，cp命令也差不多  
    + 用法：cp 现有路径 目标路径 (目标文件名)  

7. rm ***一定小心使用***  
    + 用法：rm 路径  

    但是rm默认是**不递归的**，也就是说不能删除目录，可以传递一个**-r**的flag来递归的删除  
    还有`rmdir`来专门删除空目录，`mkdir`专门建立新空白目录  

8. tail 输出其输入的末尾，默认十行  
    `tail -n1`表示输出最后1行  
    `tail -n+8`表示输出从第8行开始输出到结尾  

9. 快捷键：ctr+L，清空终端，到最上  

10. tee 从输入中读取，写到一个文件里，同时写入到标准输入流，即**同时显示在屏幕与写入到文件**  
`cat log | tee log.txt`可以同时把cat的log存入文件并显示  

11. xdg-open 自动选择合适的方式打开文件  

12. test 用来各种各样的比较运算，通过加不同的flag参数  

### 进阶：重定向与管道
每一个命令都可以认为是拥有**输入流**与**输出流**两部分，利用管道可以将不同程序的不同流进行重定向，从而结合起来  

1. **>** **输出重定向**，如`echo hello > hello.txt`，将会把原本输出到终端的输出到指定的文件  
**2>** **错误输出重定向**，一般命令执行成功会有一个输出流，执行失败也有一个输出错误流，可以用来分流两种状态的信息  
tips： `> /dev/null`的东西都会被丢弃，后面脚本中可以用这个丢弃垃圾信息  
**<** **输入重定向**，如`cat < hello.txt`，会将hello.txt中的内容输出  
**\***注：**cat hello.txt与cat < hello.txt**的区别：  
    + 两者**效果都相同**，最终都是将hello.txt的内容输出到终端  
    + 但实现**原理上不同**，要从cat的原理上看，当使用cat并**指定文件**时，会直接从文件中读取并输出  
而当cat**不指定文件**或**为"-"**时，会从标准输入读取再输出，此时刚好用"<"将标准输入重定向至文件中的内容，从而实现  

2. **>>** 追加，使用单个是覆盖，但使用两个是追加  
3. **|** 管道符，取左侧程序的输出，送到右边程序的输入  
4. 重定向与管道是相互独立的，因此sudo权限是不传递的  
    ***一些获得su权限的方法：***  
    + **sudo + 命令**，以su的权限执行  
    + **\# + 命令**(常见于一些指导代码)，指的是要以root权限运行整行程序，"$"普通用户，"#"超级用户  
    + **sudo su**登陆root用户  

### 第一次作业
+ /tmp：临时存储，基本每次启动都会删除干净，所以可以在这里尝试  
+ touch可以修改文件时间戳，同时也可以实现新建文件  
+ "#"在bash开头表示注释，用""包围的!有特殊意义，但''则没有  
+ chmod用来修改文件权限  
+ grep "关键字" file，输入为文件名，输出到标准输出，在输入中查找关键字  
+ /sys/class/power_supply中是电池信息  

***

## Lec2.Shell Tools & 脚本.sh

### bash中字符串与变量定义与引用
bash中字符串可以使用`""`与`''`围起来  

+ 对于**纯文本字符串**而言，两者效果**相同**  
+ 但是对**其他字符串**而言则不同。  
如假设有`foo=bar`(在这里命名时也有讲究，不能有空格，否则将解析为命令):  
    + `echo "value is $foo"`会输出value is bar  
    + `echo 'value is $foo'`会输出value is $foo  

    **问题：**在bash中定义的东西都存到哪了？ **答：**储存在bash中的内存环境，只在当前环境中有用，会话结束就消失  
    **问题：**如何使其持久化？ **答：**定义在*.bashrc*、*.bash_profile*、*.profile*等文件，会自动执行  

### bash中函数的定义
在bash中可以定义函数，在自动化有很大作用。可以直接写进bash中执行，但写进文件更好用。如下通过`vim mcd.sh`:  

    mcd (){  
    mkdir -p "$1"  
    cd "$1"  
    }  

随后就可通过`source mcd.sh`激活mcd函数，然后就能直接使用mcd了(同样的，source后的脚本只在当前shell有用，关掉重开就失效了)  

### bash中陌生符号的使用
#### $的用法：引用或得到或替换(但是要在""中)
+ 引用bash变量，如`a=10`后，`$a`就会认为是10了  
+ `$?`得到上一个命令的**返回值**（or错误代码，见下方退出状态码部分），如`cd ~`后，`echo $?`会显示0表示正确  
+ `$_`得到上一个命令的**最后一个参数**，如`mkdir test`后，用`cd $_`就会到test目录  
+ 可以将**命令的结果传给变量**，如`foo=$(pwd)`，就会把pwd命令的输出给foo变量  
同样的，可以直接使用替换的方式，如`echo "now in $(pwd)"`，就会输出now in 当前目录了  
+ `$0`是当前脚本的名字  
+ `$1`到`$9`是脚本的1-9个参数  
+ `$#`得到当前脚本的给定**参数数量**  
+ `$@`得到**所有参数的列表**  
+ `$$`得到当前shell进程的id（PID）  

#### !的用法：
+ `!!`会得到(替换)到上一条命令，如`apt update`会权限不足，然后用`sudo !!`即可  

### 退出状态码
所有命令都会返回一个**退出状态码**，为0是命令执行成功，为其他是失败。  

+ `true`命令的`echo $?`为0，`false`为1  
+ 可以利用逻辑运算符"&&"与"||"，采用短路运算法则，如`true || echo "1"`与`false && echo "2"`就不会有打印，因为在前面就被短路了，**但是**脑子不要糊涂，`$?`仍为0，因为成功执行了！  
    **短路运算法则：**计算与&&时，只要遇到一个false，后面的都不再进行运算；计算或||时，只要遇到一个true，后面的都不再运行  
    
+ 使用`;`在一行连接多个命令，都会执行，如`false;echo"1"`会一直输出1  

### 过程替换
在bash中，有些命令只接受文件的输入形式，为了简洁，我们不想创建临时文件，为此，可以使用**过程替换**  
+ **<(命令)**这个过程替换可以将括号内的命令存储在一个临时文件中，然后这个临时文件重定向出去，如`cat <(ls) <(ls ../)`就会分别先将`ls`与`ls ../`的结果分别存在某临时文件中，在输给cat  
+ **>(命令)**比较用不着，先空下  


### 通配
当我们寻找特定类型或包含特定字段的文件时，则可通过通配符来进行匹配  

+ **\*：**寻找后缀时，如`ls *.sh`会列出当前目录中所有的脚本文件  
+ **?：**当只要求额外匹配一个字段，如当前目录中有project1、priject2、project12时，要只匹配一个，可以用`ls project?`，这样只会匹配到1和2,而没有12  
+ **{}：****自动展开:**  
    1. 当有同名但后缀不同的文件时，可以使用这个格式，譬如有readme.txt、readme.mkd，可以用`cat readme.{mkd,txt}`来展开为原本格式；以及进行文件转换时`convert image.{png,jpg}`  
    2. 当多个文件有相同部分时，如`touch work{,1,2,10}`会展开为work,work1,work2,work10  
    3. 还可多个并列以成笛卡尔乘积，`touch project{1,2}/src/test/text{1,2}.py`会展开为`touch project1/..../test1.py project1/..../test2.py project2/..../test1.py project2/..../test2.py`  
尽快离开就立刻就开了  
    4. 配合..可以按顺序展开，如{a..z}与{1..9}等  

### Bash脚本(Script)
脚本即是将一系列的bash命令与其他运算集结在一起，直接调用的，以".sh"结尾，可以直接执行；也可定义成函数，通过source来激活。  

+ 基本语法在上面的$用法有体现  
+ 如下，定义一个名为*example.sh*的脚本来实战：  

    \#!/bin/bash  
    echo "running $0 with $# arg start at $(date), PID:$$"  
    for file in "$@";do  
        grep word "$file" > /dev/null 2> /dev/null  
        if [[ "$?" -ne 0 ]];then  
            echo "file $file no word"  
        fi  
    done  

    以上便是一个bash脚本实例，第一行的为特殊注释，来告诉系统使用bin中的bash来作为解释器来执行；if fi是条件语句的开始和结束；-ne是不等于；done是指循环结束  

    + 此外，脚本还可以用其他语言来实现，处理相关的工作问题很有用，比如python脚本，需要时再学习  

### 实用命令行
+ ***shellcheck***，可以检测.sh脚本的语法错误  
+ ***tldr***，简化的man  
+ ***find***，有用的搜索工具，通过不同的flag与options  
例如`find . -name src -name src -type d`是在当前目录下(.)递归的寻找名字为src的类型为目录的文件  
`find . -path '**/test/*.py' -type f`是在当前目录下寻找有特定路径(不限前面有多少层，最终前一层是test的py文件)的文件  
**find除搜索外还可以执行操作**，如`find . -name "*.tmp" -exec rm {} /`，会将搜索出的.tmp文件都删除掉(解释：“{}”是一个占位符，表示find搜索到的文件的路径，“/”表示exec命令的结束)  
    + 此外，还有更高级一点的fd命令，用正则表达式匹配，可以彩色输出等  
+ ***locate***，基于数据库的搜索，会事先建立所有文件的索引，用时直接匹配  
比如`locate missing`就会输出所有包含missing子串的所有路径  
但是要记得定期用`updatedb`更新索引库  
+ ***grep***与升级版**rg(ripgrep)**，有时候我们相比文件本身更关注文件内容，比如明确的记得文件内容中的关键字，就可以使用grep(rg)来进行查找  
如`grep -r namespace .`就会在当前目录中左右文件内容中寻找带有namespace  
若用rg会更高级一点，如`rg "import requests" -t py ~/scratch`，会在对应目录的py文件中搜索带有import requests的文件  
+ ***history***查找历史命令，如`history | grep retext`会查找出所有含有retext的历史命令  
+ ***ctrl + R***输入内容倒序匹配上一条相近的命令  
+ ***fzf***模糊搜索工具  
如`cat helloword.c | fzf`会将文件内容输出到fzf中实时搜索  
同时还可以自动绑定到ctrl+R快捷键上，实时模糊搜索  
+ ***nnn***可视化目录访问，类似于nautilus(就是gnome的可视化)，可以方便的查看结构  

### 第二次作业
+ `ls -a`显示隐藏文件，`-h`大小以人类可读的单位显示，`-t`按时间排序，`-r`逆序排列，`--color=auto`打开颜色  
+ 先定义一个变量`path=/`作为初始化，然后在marco函数中定义`path=$(pwd)`，在polo函数中定义`cd "$path"`  
+ 定义函数  

    \#!/bin/bash  
    test () {  
    count=0  
    err=1  
    while [ $err -eq 1 ];do  
        n=$(( RANDOM % 100 ))  

        if [[ $n -eq 42 ]]; then  
            echo "Error, n=$n" 2>> /home/liuzt/wrong.txt  
            err=0  

        else  
            echo "Right, n=$n" >> /home/liuzt/right.txt   
            count=$(($count + 1))  
        fi  
    done  

    cat /home/liuzt/right.txt /home/liuzt/wrong.txt  
    echo "right all $count"  
    }  

+ xrags命令，命令可以从*标准输入*或*参数*中获得输入，使用管道符会将标准输出与标准输入连接起来，**但是**有的命令需要从参数获取输入，例如`rm`，所以使用xrags，**使用标准输入的内容作为输入参数，例如`ls | xrags rm`(这里也给了一个解释marcopolo的问题思路：用`echo $path > cd`没有用是因为cd需要用参数输入而不是标准输入流)  
+ 编写函数

    tarhtml () {  
    find . -name "*.html" | xrags -d '\n' tar czf htmls.tar.gz  
}  
+ 编写函数：  

    lastFile () {  
    nowline=1  
  
    ls . -ltr > files.txt  
    sed -i "$nowline"d files.txt  
  
    ttlline=$(grep -c "^" files.txt)  
    
    while [$nowline -ne $ttlline];do  
        type=$(head -c1 files.txt)  
        if [$type -eq "d"];then  
            <d\>=#####  
            ls <d\> -ltr > temp.txt  
            sed -i 1d temp.txt  
            cat temp.txt >> files.txt  
            sed -i "$nowline"d files.txt  
        else  
            $nowline=$(($nowline + 1))  
        fi  
    ttlline=$(grep -c "^" files.txt)  
    done  
  
    sort #####  
}  

    没有完成的地方是<d\>的获取与最后列出大表后的sort  
    这个思路是类似广度优先搜索，一次将当前目录的所有元素列出，然后从中删除再继续  

***

##Lec3.文本编辑器Vim的使用
vim是程序员写给程序员的工具，有自己的**精妙设计与哲学**  
### 思想1：基于模式（Modal）的编辑器
***vim的核心哲学：它的接口是种编程语言***(接口：用户与它进行交互的方式、中介物)，这意味着**不同的按键组合具有不同的效果，然后将其组合在一起**

这意味vim有**多个模式**。程序员编程时往往会做不同的事：阅读代码、寻找定位某处进行小改动、写长串代码，如此不同的工作配备不同的模式。  

1. **Normal Mode**：用来**移动光标、阅读代码、文件间切换**  
    是进入Vim时默认进入的模式，"**i**"进入Insert mode，"**R**"进入Replace mode，"**v**"进入Visual mode，"**Shift+v**"进入Visual Line mode，"**Ctrl+v**"进入Visual Block mode，"**:**"进入Command Line mode  
    要从其他模式返回，只需按"**Esc**"文件（但由于不方便按到，一般会将CapsLock映射成Esc）  


### 一些基本操作
+ **`:q`** 退出当前**所在的window**，而非直接退出vim,只有全部的window都退出后才会退出vim  
**`:qa`** 退出**所有的window**  
+ **`hjkl`** 光标**逐字**移动  
**`w/b`** 光标移向**下/上一个单词**  
**`e`** 光标移向当前**单词末尾**，继续按会到下一个单词末尾  
**`0/$/^`** 光标移向**行首/行末/行首非空**  
+ **`ctrl`
+ **`:help`** 加上某特定键或命令来获取说明，进入相关文档，要退出文档返回原状态，输入**`:q`**即可  
    注，操作要具体，如`:help :w`与`:help w`不同  

### vim独特的buffer、tab、window概念
**buffer：**缓冲区，用来存储文件内容。每个缓冲区对应一个文件  
**tab：**标签页，一种组织窗口的方式。每个标签页可包含一到多个window  
**window：**窗口，屏幕上显示缓冲内容的可视区域，每个窗口可以独立显示不同缓冲内容或同一缓冲的不同区域  

**特点：**

+ vim层次结构：  
**Vim**--->包含多个**tab**  
每个**tab**--->一定数量的**window**  
每个**window**--->对应的**buffer**(一个buffer可以同时被**零或多个**buffer打开)

+ *buffer*与*window***不一定是一一对应**的关系。如输入`:sp`创建另一个窗口，显示同样的内容，可以利用这一特性同时浏览同一文件不同部分  







